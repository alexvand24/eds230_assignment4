---
title: "EDS230 Assignment 4"
author: "Charles Hendrickson, Ryan Munnikhuis, Alex Vand"
date: "4/21/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE, 
                      warning = FALSE)

library(tidyverse)
library(here)
library(pse)

#read in the atmospheric_conductance R script in order to use the function in this RMD 
source(here("atmospheric_conductance.R"))
```



#Q2
```{r}
atmospheric_conductance(v_m = 250, h = 1000)
```


```{r}
factors = c("v_m", "h", "k_d", "k_0")
```

```{r}
# number of parameter sets to run
nsets = 100
```

```{r}
q = c("qnorm", "qunif", "qnorm", "qnorm")
q_arg = list(list(mean = 250, sd = 30),    # v_m (cm/s)
             list(min = 950, max = 1050),  # h   (cm)
             list(mean = 0.7, sd = 0.01),  # k_d
             list(mean = 0.1, sd = 0.01))  # k_0
             
```


#Q3
(a) Use LHS to generate parameter values for the 4 parameters.

```{r}
sens_atmospheric_conductance = LHS(NULL, factors, nsets, q, q_arg)
sens_pars = get.data(sens_atmospheric_conductance)
head(sens_pars)
```

(b) Run your atmospheric conductance model for these parameters and return aerodynamic conductances.

```{r}
# lets now run our model for all of the parameters generated by LHS
# pmap is useful here - it is a map function that uses the actual names of input parameters

conductance <- sens_pars %>% pmap(atmospheric_conductance)

# notice that what pmap returns is a list 
head(conductance)

conductance_df <- as.data.frame(conductance)
```


```{r}
# turn results in to a dataframe for easy display/analysis
conductance_sd = conductance_df %>% map_dfr(`[`,c("maxconductance","minconductance","meanconductance"))
# add ~^here above

# to take advantage of LHS/pse functions for 
# plotting interesting information we can send results back - 
# results need to be in a matrix
# each column is a different parameter set - we can use transpose (t)
# and as.matrix to get there

# tell is what links output to original LHS object

sens_atmospheric_conductance = pse::tell(sens_atmospheric_conductance,
                                         t(as.matrix(conductance_sd)),
                                         res.names = c("maxconductance",
                                                       "minconductance",
                                                       "meanconductance"))
```



(c) Plot conductance estimates in a way that accounts for parameter uncertainty
```{r}
pse::plotscatter(sens_atmospheric_conductance, col="blue", cex=5)
```


```{r}
# we can also plot results in interesting ways
# turn sens_almond into a data frame - easier access to R plotting functions

ggplot(conductance_sd, aes(x = minconductance, y = maxconductance))+geom_point()+labs(y="Max Atmospheric Conductance ", "Min Atmospheric Conductance")
```



```{r}
# add uncertainty bounds on our estimates
tmp = yieldsd %>% gather(value="value", key="yield")
ggplot(tmp, aes(yield, value, col=yield))+geom_boxplot()+
  labs(y="Yield (as anomoly)")
```



```{r}
# note that you don't see the ranges because of the scale (min yield anomoly much smaller than max) - here's a more informative way to graph
ggplot(tmp, aes(yield, value, col=yield))+
  geom_boxplot()+labs(y="Yield (as anomoly)")+
  facet_wrap(~yield, scales="free" )
```








